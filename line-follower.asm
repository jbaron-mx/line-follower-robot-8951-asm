ORG 0000h

ACALL TT0	; 100MS DELAY

; LINE SENSORS (S1-S2-S3-S4)
SENSORES	EQU P3

; SIDE-MARK SENSORS
MARCA_IZQ	EQU P2.0
MARCA_DER	EQU P2.1

; SIDE-MARK INPUT: 1 BLACK, 0 NON-BLACK
COLOR		EQU P2.2	

; MOTOR OUTPUTS
MOTOR_IZQ	EQU P0.0
MOTOR_DER	EQU P0.1

; LED INDICATORS
LED_MARCA       EQU P1.4
LED_MARCA_IZQ   EQU P1.2
LED_MARCA_DER   EQU P1.3
LED_FINAL       EQU P1.5

; FLAGS
IZQ_BRUSCA	    EQU 020h.0  ; ABRUPT-LEFT TURN
DER_BRUSCA	    EQU 020h.1  ; ABRUPT-RIGHT TURN
MARCA_DETECTED	EQU 020h.2	; SIDE-MARK DETECTED
FINAL_DETECTED	EQU 020h.3	; END-OF-PATH DETECTED
CONT			EQU 021h	; TIMER COUNTER

; RESET VALUES
CLR MOTOR_IZQ
CLR MOTOR_DER
CLR IZQ_BRUSCA
CLR DER_BRUSCA
CLR MARCA_DETECTED
CLR FINAL_DETECTED
MOV P1, #0

; INITIALIZE TIMER_0
MOV TMOD, #00010001b
MOV TH0, #61	; SET 50MS
MOV TL0, #176	
CLR TF0

; MAIN LOOP, FOLLOW THE LINE IN NORMAL CONDITIONS
LOOP:
	; IF SIDE-MARK DETECTED
	JB MARCA_DETECTED, CHECK_MARCA2
	JB MARCA_IZQ, CHECK_MARCA
	JB MARCA_DER, CHECK_MARCA

	KEEPGOING:
	MOV A, SENSORES	

	CJNE A, #0, C1				; 0  0  0  0 <- STOP
		LJMP STOP
	C1: CJNE A, #8, C2			; 0  0  0  1 <- ABRUPT-RIGHT
		LJMP DER_MEM
	C2: CJNE A, #4, C3			; 0  0  1  0 <- RIGHT
		LJMP DERECHA
	C3: CJNE A, #12, C4			; 0  0  1  1 <- RIGHT
		LJMP DERECHA
	C4: CJNE A, #6, C5			; 0  1  1  0 <- STRAIGHT
		LJMP RECTO
	C5: CJNE A, #14, C6			; 0  1  1  1 <- RIGHT
		LJMP DERECHA
	C6: CJNE A, #1, C7			; 1  0  0  0 <- ABRUPT-LEFT
		LJMP IZQ_MEM
	C7: CJNE A, #5, C8			; 1  0  1  0 <- RIGHT
		LJMP DERECHA
	C8: CJNE A, #13, C9			; 1  0  1  1 <- RIGHT
		LJMP DERECHA
	C9: CJNE A, #15, C10		; 1  1  1  1 <- STRAIGHT
		LJMP RECTO
	C10: LJMP IZQUIERDA			; ELSE, LEFT
SJMP LOOP

GO_RECTO: LJMP RECTO

CHECK_MARCA:
	SETB LED_MARCA	; TURN-ON LED INDICATOR
	MOV CONT, #0	; RESET COUNTER
	MOV TH0, #61	; SET 50MS TO TIMER_0
	MOV TL0, #176
	CLR TF0		; RESET OVERFLOW BIT
	SETB TR0	; START TIMER_0
	SETB MARCA_DETECTED	; SET FLAG FOR SIDE-MARK DETECTED
	SJMP MARCA_RETURN	; RETURN TO MAIN LOOP
	
	CHECK_MARCA2:
		JNB TF0, MARCA_RETURN	; RETURN TO MAIN LOOP IF TIMER_0 HASN'T OVERFLOWED YET

		; ELSE, 50MS HAS PASSED
		INC CONT	; INCREASE COUNTER BY 1
		CLR TF0	; RESET OVERFLOW BIT FOR TIMER_0
		
		MOV TL0, #176	; SET 50MS TO TIMER_0
		MOV TH0, #61
		MOV R0, CONT
		CJNE R0, #12, MARCA_RETURN	; RETURN TO MAIN LOOP IF 0.5 SEG HASN'T PASSED YET
		
		; ELSE, 2 SEG HAS PASSED
		AFTER2SEG:
			CLR LED_MARCA	; CLEAR LED INDICATOR
			CLR TR0	; STOP TIMER_0
			CLR TF0	; RESET OVERFLOW BIT
			MOV CONT, #0	; RESET COUNTER
			CLR MARCA_DETECTED	; CLEAR FLAG FOR SIDE-MARK DETECTED
		
			; VERIFY IF SIDE-MARK SENSORS STILL DETECTING SOMETHING
			JB MARCA_IZQ, HAY_MARCA_IZQ
			JB MARCA_DER, HAY_MARCA_DER
			SJMP MARCA_RETURN	; ELSE, RETURN TO MAIN LOOP
			
			; LEFT SIDE-MARK DETECTED
			HAY_MARCA_IZQ:
				JNB COLOR, GRIS_DER	; JUMP TO OTHER MODE IF GRAY SELECTED
				GRIS_IZQ:
				SETB LED_MARCA_IZQ	; TURN ON LED INDICATOR
				
				MOV TH0, #61	; SET 50MS TO TIMER_0
				MOV TL0, #176
				SETB TR0	; START TIMER_0
				SJMP MARCA_RETURN_IZQ	; RETURN TO LEFT-BORDER FOLLOWER LOOP

				IZQ_5SEG:
					JNB TF0, MARCA_RETURN_IZQ	; RETURN TO LEFT-BORDER FOLLOWER LOOP IF TIMER_0 HASN'T OVERFLOWED

					; 50MS HAS PASSED
					INC CONT	; INCREASE COUNTER BY 1
					CLR TF0	; RESET OVERFLOW BIT FOR TIMER_0
					
					MOV TL0, #176	; SET 50MS TO TIMER_0
					MOV TH0, #61
					MOV R0, CONT
					CJNE R0, #40, MARCA_RETURN_IZQ	; RETURN TO LEFT-BORDER FOLLOWER LOOP IF NOT OVER 3SEG

					; 5SEG HAS PASSED
					CLR LED_MARCA_IZQ	; CLEAR LED INDICATOR
					CLR TR0	; STOP TIMER_0
					CLR MARCA_DETECTED	; CLEAR FLAG SIDE-MARK DETECTED
					SJMP MARCA_RETURN	; RETURN TO MAIN LOOP

			HAY_MARCA_DER:
				JNB COLOR, GRIS_IZQ	; JUMP TO OTHER MODE IF GRAY SELECTED
				GRIS_DER:
				SETB LED_MARCA_DER	; TURN ON LED INDICATOR
				
				MOV TH0, #61	; SET 50MS TO TIMER_0
				MOV TL0, #176
				SETB TR0	; START TIMER_0
				SJMP MARCA_RETURN_DER	; RETURN TO RIGHT-BORDER FOLLOWER LOOP

				DER_5SEG:
					JNB TF0, MARCA_RETURN_DER	; RETURN TO RIGHT-BORDER FOLLOWER LOOP IF TIMER_0 HASN'T OVERFLOWED

					; 50MS HAS PASSED
					INC CONT	; INCREASE COUNTER BY 1
					CLR TF0	; RESET OVERFLOW BIT FOR TIMER_0
					
					MOV TL0, #176	; SET 50MS TO TIMER_0
					MOV TH0, #61
					MOV R0, CONT
					CJNE R0, #40, MARCA_RETURN_DER	; RETURN TO RIGHT-BORDER FOLLOWER LOOP IF NOT OVER 3SEG

					; 5SEG HAS PASSED
					CLR LED_MARCA_DER	; CLEAR LED INDICATOR
					CLR TR0	; STOP TIMER_0
					CLR MARCA_DETECTED	; CLEAR FLAG SIDE-MARK DETECTED
					SJMP MARCA_RETURN	; RETURN TO MAIN LOOP

	MARCA_RETURN_IZQ: SJMP IZQ_KEEPGOING
	MARCA_RETURN_DER: SJMP DER_KEEPGOING
	MARCA_RETURN:
LJMP KEEPGOING

; SUPPORTING LOOP TO FOLLOW LEFT-BORDER OF THE LINE
BORDE_IZQ_LOOP:
	SJMP IZQ_5SEG

	IZQ_KEEPGOING:
	MOV A, SENSORES

	CJNE A, #0, BI1				; 0  0  0  0 <- REMEMBER TURN
		LJMP BI_MEM
	BI1: CJNE A, #8, BI2		; 0  0  0  1 <- RIGHT
		LJMP BI_DERECHA
	BI2: CJNE A, #4, BI3		; 0  0  1  0 <- STRAIGHT
		LJMP BI_RECTO
	BI3: CJNE A, #12, BI4		; 0  0  1  1 <- STRAIGHT
		LJMP BI_RECTO
	BI4: CJNE A, #1, BI5		; 1  0  0  0 <- LEFT, REMEMBER TURN
		LJMP BI_IZQ_MEM
	BI5: LJMP BI_IZQUIERDA		; ELSE, LEFT
SJMP BORDE_IZQ_LOOP

; SUPPORTING LOOP TO FOLLOW RIGHT-BORDER OF THE LINE
BORDE_DER_LOOP:
	SJMP DER_5SEG
	
	DER_KEEPGOING:
	MOV A, SENSORES

	CJNE A, #0, BD1				; 0  0  0  0 <- REMEMBER TURN
		LJMP BD_MEM
	BD1: CJNE A, #8, BD2		; 0  0  0  1 <- RIGHT, REMEMBER TURN
		LJMP BD_DER_MEM
	BD2: CJNE A, #2, BD3		; 0  1  0  0 <- STRAIGHT
		LJMP BD_RECTO
	BD3: CJNE A, #1, BD4		; 1  0  0  0 <- LEFT
		LJMP BD_IZQUIERDA
	BD4: CJNE A, #3, BD5		; 1  1  0  0 <- STRAIGHT
		LJMP BD_RECTO
	BD5: LJMP BD_DERECHA		; ELSE, RIGHT
SJMP BORDE_DER_LOOP

ANTESDETERMINAR:
	SETB LED_FINAL	; TURN ON LED INDICATOR
	SETB FINAL_DETECTED	; TURN ON FLAG OF END-OF-PATH DETECTED
	SETB MOTOR_IZQ	; TURN BOTH MOTORS
	SETB MOTOR_DER	
	ACALL TT0	; 100MS DELAY
	CLR LED_FINAL	; CLEAR LED INDICATOR
LJMP KEEPGOING	; RETURN TO MAIN LOOP ONCE MORE TO VERIFY IF SENSORS ARE DETECTING ANYTHING

; 130uS DELAY
TT0: MOV R7, #253
	MOV R6, #231
TT1: DJNZ R6, TT1
	DJNZ R7, TT1
RET

; <----------------------- MAIN LOOP ACTIONS --------------------------->

; NOT MOVING
STOP:
	; IF ABRUPT TURN WAS MADE AND NO LINE IS DETECTED
	; THEN IT WILL KEEP TURNING TO THE SAME SIDE
	JB DER_BRUSCA, STOP_RETURN
	JB IZQ_BRUSCA, STOP_RETURN

	; IF NOT ABRUPT TURN WAS MADE, THEN IT MEANS
	; IT IS THE END OF THE PATH SO IT WILL STOP COMPLETELY
	; BUT BEFORE STOPING IT WILL MOVE FORWARD BY 1CM TO DISCARD IT IS IN A CURVE AND IT HAS LOST THE LINE
	JNB FINAL_DETECTED, ANTESDETERMINAR
	CLR MOTOR_IZQ
	CLR MOTOR_DER
	ACALL CLEAN_MEM_FLAGS

	STOP_RETURN:
LJMP LOOP

; TURN RIGHT
DERECHA:
	CLR MOTOR_DER
	SETB MOTOR_IZQ

	ACALL CLEAN_MEM_FLAGS
	CLR FINAL_DETECTED
LJMP LOOP

; TURN ABRUPT-RIGHT
DER_MEM:
	CLR MOTOR_DER
	SETB MOTOR_IZQ

	; SET FLAG FOR ABRUPT-TURN
	; SO IF IT LOSE THE LINE IT WILL REMEMBER THE TURN DIRECTION
	SETB DER_BRUSCA
	CLR IZQ_BRUSCA

	CLR FINAL_DETECTED
LJMP LOOP

; TURN LEFT
IZQUIERDA:
	CLR MOTOR_IZQ
	SETB MOTOR_DER

	ACALL CLEAN_MEM_FLAGS
	CLR FINAL_DETECTED
LJMP LOOP

; TURN ABRUPT-LEFT
IZQ_MEM:
	CLR MOTOR_IZQ
	SETB MOTOR_DER
	
	; SET FLAG FOR ABRUPT-TURN
	; SO IF IT LOSE THE LINE IT WILL REMEMBER THE TURN DIRECTION
	SETB IZQ_BRUSCA
	CLR DER_BRUSCA

	CLR FINAL_DETECTED
LJMP LOOP

; STRAIGHT
RECTO:
	SETB MOTOR_IZQ
	SETB MOTOR_DER

	ACALL CLEAN_MEM_FLAGS
	CLR FINAL_DETECTED
LJMP LOOP

CLEAN_MEM_FLAGS:
	CLR DER_BRUSCA
	CLR IZQ_BRUSCA
RET

; <----------------------- ACTIONS FOR SUPPORTING LEFT-BORDER LOOP --------------------------->
; REMEMBER TURN DIRECTION
BI_MEM:
	; IF ABRUPT-TURN WAS MODE AND NO LINE IS DETECTED
	; THEN IT WILL KEEP SPINNING TO THE SAME DIRECTION
	JB DER_BRUSCA, BI_MEM_RETURN
	JB IZQ_BRUSCA, BI_MEM_RETURN
	BI_MEM_RETURN:
LJMP BORDE_IZQ_LOOP

; TURN RIGHT
BI_DERECHA:
	CLR MOTOR_DER
	SETB MOTOR_IZQ

	ACALL CLEAN_MEM_FLAGS
LJMP BORDE_IZQ_LOOP

; TURN LEFT
BI_IZQUIERDA:
	CLR MOTOR_IZQ
	SETB MOTOR_DER

	ACALL CLEAN_MEM_FLAGS
LJMP BORDE_IZQ_LOOP

; TURN LEFT | REMEMBER TURN DIRECTION
BI_IZQ_MEM:
	CLR MOTOR_IZQ
	SETB MOTOR_DER
	
	; SET FLAG FOR ABRUPT-TURN
	; SO IF IT LOSE THE LINE IT WILL REMEMBER THE TURN DIRECTION
	SETB IZQ_BRUSCA
	CLR DER_BRUSCA
LJMP BORDE_IZQ_LOOP

; STRAIGHT
BI_RECTO:
	SETB MOTOR_IZQ
	SETB MOTOR_DER

	ACALL CLEAN_MEM_FLAGS
LJMP BORDE_IZQ_LOOP

; <----------------------- ACTIONS FOR SUPPORTING RIGHT-BORDER LOOP --------------------------->
; REMEMBER TURN DIRECTION
BD_MEM:
	; IF ABRUPT-TURN WAS MODE AND NO LINE IS DETECTED
	; THEN IT WILL KEEP SPINNING TO THE SAME DIRECTION
	JB DER_BRUSCA, BD_MEM_RETURN
	JB IZQ_BRUSCA, BD_MEM_RETURN
	BD_MEM_RETURN:
LJMP BORDE_DER_LOOP

; TURN RIGHT
BD_DERECHA:
	CLR MOTOR_DER
	SETB MOTOR_IZQ

	ACALL CLEAN_MEM_FLAGS
LJMP BORDE_DER_LOOP

; TURN LEFT
BD_IZQUIERDA:
	CLR MOTOR_IZQ
	SETB MOTOR_DER

	ACALL CLEAN_MEM_FLAGS
LJMP BORDE_DER_LOOP

; TURN RIGHT | REMEMBER TURN DIRECTION
BD_DER_MEM:
	CLR MOTOR_DER
	SETB MOTOR_IZQ

	; SET FLAG FOR ABRUPT-TURN
	; SO IF IT LOSE THE LINE IT WILL REMEMBER THE TURN DIRECTION
	SETB DER_BRUSCA
	CLR IZQ_BRUSCA
LJMP BORDE_DER_LOOP

; STRAIGHT
BD_RECTO:
	SETB MOTOR_IZQ
	SETB MOTOR_DER

	ACALL CLEAN_MEM_FLAGS
LJMP BORDE_DER_LOOP


FINAL:
SJMP $
END